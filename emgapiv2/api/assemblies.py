from django.http import Http404
from ninja_extra import api_controller, http_get, paginate
from ninja_extra.schemas import NinjaPaginationResponseSchema

import analyses.models
from analyses.schemas import (
    Assembly,
    AssemblyDetail,
    MGnifyAnalysis,
    GenomeAssemblyLinkSchema,
    AdditionalContainedGenomeSchema,
)
from emgapiv2.api.perms import UnauthorisedIsUnfoundController
from emgapiv2.api.schema_utils import (
    make_links_section,
    make_related_detail_link,
    make_child_link,
    ApiSections,
)
from genomes.models import GenomeAssemblyLink, AdditionalContainedGenomes


def _get_single_assembly_by_accession_or_404(
    accession: str,
) -> analyses.models.Assembly:
    """
    Return a single Assembly matching the given ENA accession contained in ena_accessions.
    """
    qs = analyses.models.Assembly.public_objects.filter(
        ena_accessions__contains=[accession]
    ).order_by("-id")
    assembly = qs.first()
    if assembly is None:
        raise Http404("Assembly not found.")
    return assembly


@api_controller("assemblies", tags=[ApiSections.ANALYSES])
class AssemblyController(UnauthorisedIsUnfoundController):
    @http_get(
        "/",
        response=NinjaPaginationResponseSchema[Assembly],
        summary="List all assemblies available in MGnify",
        description=(
            "Each assembly represents a collection of contigs generated by assembling sequencing reads from an MGnify or run "
        ),
        operation_id="list_assemblies",
    )
    @paginate()
    def list_assemblies(self):
        return analyses.models.Assembly.public_objects.all()

    @http_get(
        "/{accession}",
        response=AssemblyDetail,
        summary="Get assembly by accession",
        description=("Get detailed information about a specific assembly. "),
        operation_id="get_assembly",
        openapi_extra=make_links_section(
            {
                **make_related_detail_link(
                    related_detail_operation_id="get_mgnify_study",
                    related_object_name="study",
                    self_object_name="assembly",
                    related_id_in_response="reads_study_accession",
                ),
                **make_related_detail_link(
                    related_detail_operation_id="get_mgnify_sample",
                    related_object_name="study",
                    self_object_name="analysis",
                    related_id_in_response="study_accession",
                ),
                **make_child_link(
                    operation_id="list_genome_links_for_assembly",
                    child_name="genome-links",
                    self_object_name="assembly",
                    description="Genome/MAG links for this assembly",
                ),
                **make_child_link(
                    operation_id="list_additional_contained_genomes_for_assembly",
                    child_name="additional-contained-genomes",
                    self_object_name="assembly",
                    description="Additional contained genomes discovered for this assembly",
                ),
            }
        ),
    )
    def get_assembly(self, accession: str):
        base = _get_single_assembly_by_accession_or_404(accession)
        # Re-fetch with select_related for detailed response
        assembly = analyses.models.Assembly.public_objects.select_related(
            "run", "sample", "reads_study", "assembly_study", "assembler"
        ).get(pk=base.pk)
        return assembly

    @http_get(
        "/{accession}/genome-links",
        response=NinjaPaginationResponseSchema[GenomeAssemblyLinkSchema],
        summary="List genome/MAG links for an assembly",
        description=(
            "Return genome links (e.g. MAG associations) for a specific assembly.\n"
            "Accessible at `/assemblies/{accession}/genome-links`."
        ),
        operation_id="list_genome_links_for_assembly",
    )
    @paginate()
    def list_genome_links_for_assembly(self, accession: str):
        assembly = _get_single_assembly_by_accession_or_404(accession)

        genome_links_query_set = GenomeAssemblyLink.objects.select_related(
            "genome", "genome__catalogue"
        ).filter(assembly=assembly)

        return genome_links_query_set

    @http_get(
        "/{accession}/additional-contained-genomes",
        response=NinjaPaginationResponseSchema[AdditionalContainedGenomeSchema],
        summary="List additional contained genomes for an assembly",
        description=(
            "Return additional contained genomes (and their metrics) discovered for this assembly.\n"
            "Accessible at `/assemblies/{accession}/additional-contained-genomes`."
        ),
        operation_id="list_additional_contained_genomes_for_assembly",
    )
    @paginate()
    def list_additional_contained_genomes_for_assembly(self, accession: str):
        assembly = _get_single_assembly_by_accession_or_404(accession)
        additional_contained_genomes_query_set = (
            AdditionalContainedGenomes.objects.select_related(
                "genome", "genome__catalogue", "run"
            ).filter(assembly=assembly)
        )
        return additional_contained_genomes_query_set

    @http_get(
        "/{accession}/analyses",
        response=NinjaPaginationResponseSchema[MGnifyAnalysis],
        summary="List analyses for an assembly",
        description=(
            "Return MGnify analyses (MGYAs) that were generated from this assembly.\n"
            "Accessible at `/assemblies/{accession}/analyses`."
        ),
        operation_id="list_analyses_for_assembly",
    )
    @paginate()
    def list_analyses_for_assembly(self, accession: str):
        # Ensure assembly exists (404 if not found) and resolve to a single Assembly
        assembly = _get_single_assembly_by_accession_or_404(accession)
        qs = analyses.models.Analysis.public_objects.select_related(
            "study", "sample", "run", "assembly"
        ).filter(assembly=assembly)
        return qs
